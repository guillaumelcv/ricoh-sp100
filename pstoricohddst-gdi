#!/usr/bin/env bash

# CUPS filter file
# Author: madlynx (github.com/madlynx)
# Last change: 18.01.2020 by mishta-real (github.com/mishta-real)

# Debug mode: change to 'yes' to enable
# (SP 100 will not print)
DEBUG=no

# CONSTANTS
# End-of-line for PJL (CRLF)
readonly EOL=$(printf \\r\\n)

# Command line parameters
readonly JOB_ID=$1          # Job ID
readonly USER_NAME=$2       # User started the job
readonly FILE_NAME=$3       # File to print
readonly COPIES_NUMBER=$4   # Number of copies to print
readonly OPTIONS=$5         # Job parameters

# Temporary directory
readonly TMP_DIR="/tmp/pstoricohddst-gdi-$JOB_ID"
mkdir -p "$TMP_DIR"

# Date of printing
readonly PRINT_DATE=$(date "+%Y/%m/%d %H:%M:%S")

function log() {
  [[ $DEBUG = "yes" ]] && echo "$@" | logger -t "$0[$$]"
}

function logpipe() {
  [[ $DEBUG = "yes" ]] && echo "$@" | logger -t "$0[$$]"
}

function trapINT() {
  log "trapINT()"
  [ "x$trp" = "x" ] &&  trp="yes" || return
  sleep 30 && { [[ $DEBUG != "yes" ]] && rm -rf "$TMP_DIR"; log "Cleanup complete"; } &
  exit
}

function stop() {
  log "Stop stop page";
  echo "stop" > "$TMP_DIR"/999999999-page.pbm
}

function flush_pjl_header() {
  cat <<EOF
%-12345X@PJL$EOL
@PJL SET TIMESTAMP=$PRINT_DATE$EOL
@PJL SET FILENAME=$FILE_NAME$EOL
@PJL SET COMPRESS=JBIG$EOL
@PJL SET USERNAME=$USER_NAME$EOL
@PJL SET COVER=OFF$EOL
@PJL SET HOLD=OFF$EOL
EOF
}

function flush_pjl_footer() {
  cat <<EOF
@PJL EOJ$EOL
%-12345X
EOF
}

function flush_page_header() {
  cat <<EOF
@PJL SET PAGESTATUS=START$EOL
@PJL SET COPIES=$COPIES_NUMBER$EOL
@PJL SET MEDIASOURCE=$mediasource$EOL
@PJL SET MEDIATYPE=PLAINRECYCLE$EOL
@PJL SET PAPER=$pagesize$EOL
@PJL SET PAPERWIDTH=$width$EOL
@PJL SET PAPERLENGTH=$height$EOL
@PJL SET RESOLUTION=$resolution$EOL
@PJL SET IMAGELEN=$image_size$EOL
EOF
}

function flush_page_footer() {
  cat <<EOF
@PJL SET DOTCOUNT=1132782$EOL
@PJL SET PAGESTATUS=END$EOL
EOF
}

function flush_image() {
  log "Flushing image $page"
  cat "$TMP_DIR"/raster.jbig
}

function convert_to_pbmraw() {
  log "Converting document to pages"
  gs -dQUIET -dBATCH -dNOPAUSE -dNOSAFER -r"$resolution" -sDEVICE=ps2write -sOutputFile=- - \
    | gs -dQUIET -dBATCH -dNOPAUSE -dNOSAFER -r"$resolution" -sDEVICE=pbmraw -sOutputFile="$TMP_DIR"/%03d-page.pbm -
  log "Conversion complete"
}

function convert_to_jbig() {
  pbmtojbg -p 72 -o 3 -m 0 -q < "$TMP_DIR"/"$page" > "$TMP_DIR"/raster.jbig
}

function get_image_size() {
  image_size=$(wc -c < "$TMP_DIR"/raster.jbig)
}

function get_image_dimensions() {
  width=$(identify -format "%w" "$TMP_DIR"/"$page")
  height=$(identify -format "%h" "$TMP_DIR"/"$page")
  log "Identified as ${width}x${height}"
}

function print_page() {
  # Converting page to JBIG format
  # (parameters are very special for this printer!)
  convert_to_jbig

  # Taking image size
  get_image_size

  # Taking image dimensions
  get_image_dimensions

  # Flushing page header
  flush_page_header

  # Flushing image
  flush_image

  # Flushing page footer
  # TODO: pixelcount for toner estimate
  flush_page_footer
}


# ======== MAIN ========
log "Called with cmdline: $0 $*"

trap "stop; trapINT" SIGINT SIGTERM SIGQUIT
#trap 'echo No' SIGINT SIGTERM SIGQUIT EXIT

pagesize="A4"
resolution="600"
mediasource="TRAY1"

for option in $OPTIONS; do
  case "$option" in
    PageSize=*)
      pagesize=$(echo "${option#PageSize=}" | tr '[:lower:]' '[:upper:]')
      ;;
    InputSlot=*)
      mediasource=${option#InputSlot=}
      ;;
  esac
done

if [[ $DEBUG = "yes" ]]; then
  exec > "$TMP_DIR"/output.stream #> >(tee "$TMP_DIR"/output.stream)
fi


if [[ -x $(which inotifywait) ]]; then
  log "Asynchronous variant"
  (
    stage="empty"
    inotifywait -rmq -e close_write --format "%f" "$TMP_DIR" \
      | grep --line-buffered "page.pbm$" \
      | while read -r page; do
          log "Page submitted"

          if [[ $stage = "empty" ]]; then
            log "1st stage. Flushing PJL header."
            flush_pjl_header
            stage="printing"
          fi

	  if [[ $page = "999999999-page.pbm" ]]; then
	    log "Last stage. Flushing PJL footer."
            flush_pjl_footer

            pid=$(pgrep "$TMP_DIR")
	    [[ -n $pid ]] && kill "$pid"
	    break
          fi

	  if [[ $stage = "printing" ]]; then
            print_page
          fi
        done
  ) &
  # Converting from PostScript to PostScript-monochrome,
  # then to PBM image format (per page)
  convert_to_pbmraw
  stop
  wait

  trapINT
else
  log "Synchronous variant"

  # Converting from PostScript to PostScript-monochrome,
  # then to PBM image format (per page)
  convert_to_pbmraw

  # Flushing PJL header
  flush_pjl_header

  for page in "$TMP_DIR"/*-page.pbm; do
    log "Page $page"
    print_page
  done

  # Flushing PJL footer
  flush_pjl_footer
fi

[[ $DEBUG != "yes" ]] && rm -rf "$TMP_DIR"

exit 0
