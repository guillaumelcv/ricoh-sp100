#!/usr/bin/env bash

# CUPS filter file
# Author: madlynx (github.com/madlynx)
# Last change: 18.01.2020 by mishta-real (github.com/mishta-real)


# Debug mode: change to 'yes' to enable
# (SP 100 will not print)
DEBUG=no


# CONSTANTS
# End-of-line for PJL (CRLF)
readonly EOL=$(printf \\r\\n)

# Command line parameters
readonly JOB_ID=$1          # Job ID
readonly USER_NAME=$2       # User started the job
readonly FILE_NAME=$3       # File to print
readonly COPIES_NUMBER=$4   # Number of copies to print
readonly OPTIONS=$5         # Job parameters

# Temporary directory
readonly TMP_DIR="/tmp/pstoricohddst-gdi-$JOB_ID"
mkdir -p "$TMP_DIR"

# Date of printing
readonly PRINT_DATE=$(date "+%Y/%m/%d %H:%M:%S")

function log() {
  [[ $DEBUG = "yes" ]] && echo "$@" | logger -t "$0[$$]"
}

function logpipe() {
  [[ $DEBUG = "yes" ]] && echo "$@" | logger -t "$0[$$]"
}

function trapINT() {
  log "trapINT()"
  [[ -z $trp ]] && trp="yes" || return
  sleep 30 && {
      [[ $DEBUG != "yes" ]] && rm -rf "$TMP_DIR"; log "Cleanup complete";
  } &
  exit
}

function stop() {
  log "Stop stop page";
  echo "stop" > "$TMP_DIR"/999999999-page.pbm
}

function flush_pjl_header() {
  cat <<EOF
%-12345X@PJL$EOL
@PJL SET TIMESTAMP=$PRINT_DATE$EOL
@PJL SET FILENAME=$FILE_NAME$EOL
@PJL SET COMPRESS=JBIG$EOL
@PJL SET USERNAME=$USER_NAME$EOL
@PJL SET COVER=OFF$EOL
@PJL SET HOLD=OFF$EOL
EOF
}

function flush_pjl_footer() {
  cat <<EOF
@PJL EOJ$EOL
%-12345X
EOF
}

function kill_tmpdir_process() {
  pid=$(pgrep "$TMP_DIR")

  if [[ -n $pid ]]; then
    kill "$pid"
  fi
}

function flush_page_header() {
  cat <<EOF
@PJL SET PAGESTATUS=START$EOL
@PJL SET COPIES=$COPIES_NUMBER$EOL
@PJL SET MEDIASOURCE=$mediasource$EOL
@PJL SET MEDIATYPE=PLAINRECYCLE$EOL
@PJL SET PAPER=$pagesize$EOL
@PJL SET PAPERWIDTH=$width$EOL
@PJL SET PAPERLENGTH=$height$EOL
@PJL SET RESOLUTION=$resolution$EOL
@PJL SET IMAGELEN=$image_size$EOL
EOF
}

function flush_page_footer() {
  cat <<EOF
@PJL SET DOTCOUNT=$dots$EOL
@PJL SET PAGESTATUS=END$EOL
EOF
}

function flush_image() {
  log "Flushing image $page"
  cat "$TMP_DIR"/raster.jbig
}

function convert_to_pbmraw() {
  log "Converting document to pages"
  # I wasn't able to print until I set -dNOSAFER for gs
  gs -dQUIET -dBATCH -dNOPAUSE -dNOSAFER -r"$resolution" -sDEVICE=ps2write -sOutputFile=- - \
    | gs -dQUIET -dBATCH -dNOPAUSE -dNOSAFER -r"$resolution" -sDEVICE=pbmraw -sOutputFile="$TMP_DIR"/%03d-page.pbm -
  log "Conversion complete"
}

function convert_to_jbig() {
  pbmtojbg -p 72 -o 3 -m 0 -q < "$TMP_DIR"/"$page" > "$TMP_DIR"/raster.jbig
}

function get_image_size() {
  image_size=$(wc -c < "$TMP_DIR"/raster.jbig)
}

function get_image_parameters() {
  width=$(identify -format "%w" "$TMP_DIR"/"$page")
  height=$(identify -format "%h" "$TMP_DIR"/"$page")

  log "Identified as ${width}x${height}"

  # Solution for hardcoded dots suggested by Fenisu (github.com/Fenisu)
  # at github.com/madlynx/ricoh-sp100/issues/45
  average_color=$(identify -format "%[fx:mean]" "$TMP_DIR"/"$page")
  dots=$(echo "($width * $height * (1 - $average_color)) / 1" | bc)
  dots=$(echo "$dots/100" | bc)
}

function print_page() {
  # Converting page to JBIG format
  # (parameters are very special for this printer!)
  convert_to_jbig

  # Taking image size
  get_image_size

  # Taking image dimensions
  get_image_parameters

  # Flushing page header
  flush_page_header

  # Flushing image
  flush_image

  # Flushing page footer
  flush_page_footer
}

function main() {
  log "Called with cmdline: $0 $*"

  trap "stop; trapINT" SIGINT SIGTERM SIGQUIT
  # trap 'echo No' SIGINT SIGTERM SIGQUIT EXIT

  pagesize="A4"
  resolution="600"
  mediasource="TRAY1"

  for option in $OPTIONS; do
    case "$option" in
      PageSize=*)
        pagesize=$(echo "${option#PageSize=}" | tr '[:lower:]' '[:upper:]')
        ;;
      Resolution=*)
        resolution=${option#Resolution=}
        resolution=${resolution%dpi}
        ;;
      InputSlot=*)
        mediasource=${option#InputSlot=}
        ;;
    esac
  done

  if [[ $DEBUG = "yes" ]]; then
    exec > "$TMP_DIR"/output.stream #> >(tee "$TMP_DIR"/output.stream)
  fi

  if [[ -x $(which inotifywait) ]]; then
    log "Asynchronous variant"
    (
      stage="empty"
      inotifywait -rmq -e close_write --format "%f" "$TMP_DIR" \
        | grep --line-buffered "page.pbm$" \
        | while read -r page; do
            log "Page submitted"

            if [[ $stage = "empty" ]]; then
              log "1st stage. Flushing PJL header."
              flush_pjl_header
              stage="printing"
            fi

	    if [[ $page = "999999999-page.pbm" ]]; then
	      log "Last stage. Flushing PJL footer."
              flush_pjl_footer
              kill_tmpdir_process
	      break
            fi

	    if [[ $stage = "printing" ]]; then
              print_page
            fi
          done
    ) &
    # Converting from PostScript to PostScript-monochrome, then to
    # PBM image format (per page)
    convert_to_pbmraw

    stop
    wait

    trapINT
  else
    # NOTE: Synchronous doesn't work for me, my SP 100SU just freezes
    log "Synchronous variant"

    # Converting from PostScript to PostScript-monochrome, then to
    # PBM image format (per page)
    convert_to_pbmraw

    # Flushing PJL header
    flush_pjl_header

    for page in "$TMP_DIR"/*-page.pbm; do
      log "Page $page"
      print_page
    done

    # Flushing PJL footer
    flush_pjl_footer
  fi

  # Remove temp dir if not debugging
  [[ $DEBUG != "yes" ]] && rm -rf "$TMP_DIR"

  exit 0
}

main "$@"

